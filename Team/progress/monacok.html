<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->

<!--Content-->
<title>ECE477 Progress Report</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="../../css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="../../css/responsive.css">
<link rel="stylesheet" href="../../css/styles.css">
<link rel="stylesheet" href="../../css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="../../Files/img/BannerImgExample.jpg">
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Kennedy Monaco</h2>
            
            <h4>Week 3:</h4>
            <b>Date:</b> 11 September 2020<br>
            <b>Total hours:</b> 7<br>
            <b>Description of design efforts:</b><br>
            <table>
                <tr>
                    <td style="width: 200px; text-align: center; font-size: 10px; margin-bottom: 0px; padding: 0; line-height: 15px;"><img src="../img/monacok_progress/SparkFun_OLED.jpg" style="height: 100px;"><br><b>Figure 1: </b><i>SparkFun TOLED Graphical Breakout Display </i>[1]</td>
                    <td>My main focus this week was researching different Transparent OLED displays to use in our
                        project and determining which component specifications were the most important to consider
                        when choosing our display. After comparing three different displays, I decided on the SparkFun
                        Transparent Graphical OLED Breakout display. This display supports I2C and SPI interfaces.
                        I performed preliminary research to review each protocol and determine the pros and cons of
                        using one or the other.</td>
                </tr>
            </table>
            <br>I2C and SPI are serial communication protocols commonly used to transfer data between a microcontroller
            and peripheral devices. Both utilize the Master-Slave relationship scheme for their functionality.<br><br>
            <table>
                <tr>
                    <td style="text-align: center; font-size: 10px; margin-bottom: 0px; padding-right: 10px; line-height: 15px;"><img src="../img/monacok_progress/SPI_Set_up.png" style="height: 150px;"><br><b>Figure 2: </b><i>SPI Master-Slave Diagram </i>[2]</td>
                    <td>SPI uses 4 basic signals for communication: SCLK, MOSI, MISO, and SS. SCLK is the Serial Clock
                        that allows the master and slave to communicate synchronously and is defined by the Master.
                        MOSI (Master Out Slave In) is the pin through which the Master sends data to the Slave. MISO
                        (Master In Slave Out) is the pin through which the Slave sends data back to the Master.
                        Finally, SS (Slave Select) lets the slave know that the Master is trying to communicate with it.
                        Having multiple Slave Selects allows multiple Slaves to be connected to one Master. The SS
                        signal attached to the desired slave is pulled low to indicate which slave the Master wishes to
                        communicate with. Data can be sent serially to and from the slave until the transmission is complete.</td>
                </tr>
            </table>
            <br>
            I2C uses 2 basic signals for communication: SCL and SDA. SCL is the Serial Clock that allows the master and
            slave to communicate synchronously and is defined by the Master. SDA is the Serial Data signal that can
            send information to and from the Master and Slave. Unlike SPI which sends data in a continuous stream of
            bits, I2C sends data bits through packets. The packet includes a Start bit, an Address Frame to indicate
            which Slave is in use, a Read/Write bit, an ACK/NACK bit, one or more data frames (which include 8 bits of
            data followed by an ACK/NACK bit), and a Stop bit to signal the end of the packet.<br>
            <p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/I2C_Message.png" style="width: 500px;"><br><b>Figure 3: </b><i>I2C Packet Structure </i>[3]</b></p>
            <br>
            Between the two protocols, SPI is preferred because it is able to transfer data faster than I2C so that
            the display can more quickly relay user metric information and toggle between screens as needed. The
            microcontrollers we are currently considering have 3 SPI peripherals which accommodates the OLED Display,
            LoRa Radio Transceiver, and IMU Receiver - the three components that require SPI in our design. In the event
            that a different component requires the use of SPI, the OLED can be converted to using I2C in exchange for
            increased display update time.
            <br><br>
            <b>Sources Cited:</b><br>
            <p style="line-height: 20px;">[1] SparkFun.com. 2020. <i>SparkFun Electronics.</i> [online] Available at: &lthttps://www.sparkfun.com/products/15173> [Accessed 8 September 2020].<br>
                [2] SparkFun.com. 2020. <i>SparkFun Electronics.</i> [online] Available at: &lthttps://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all> [Accessed 10 September 2020].<br>
                [3] CircuitBasics.com. 2020. <i>Circuit Basics.</i> [online] Available at: &lthttps://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/#:~:text=I2C%20is%20a%20serial%20communication,the%20master%20and%20the%20slave.> [Accessed 10 September 2020].</p>

            <br><b>References:</b><br>
            <p style="line-height: 20px;">CircuitBasics.com. 2020. <i>Circuit Basics.</i> [online] Available at: &lthttps://www.circuitbasics.com/basics-of-the-spi-communication-protocol> [Accessed 10 September 2020].<br>
                CircuitBasics.com. 2020. <i>Circuit Basics.</i> [online] Available at: &lthttps://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/> [Accessed 10 September 2020].<br>
                Articles.Saleae.com. 2020. <i>Saleae Articles.</i> [online] Available at: &lthttps://articles.saleae.com/logic-analyzers/spi-vs-i2c-protocol-differences-and-things-to-consider> [Accessed 10 September 2020].
            </p>
            <hr style="width: 70%; color: black; text-align: center; display: block; height: 1px; background-color: black; border: 0; margin-top: 40px; margin-bottom: 40px;">

            <h4>Week 4:</h4>
            <b>Date:</b> 18 September 2020<br>
            <b>Total hours:</b> 12<br>
            <b>Description of design efforts:</b><br><br>
            <table>
                <tr>
                    <td style="width: 50%; text-align: center;"><img src="../img/monacok_progress/CostAnalysis1.PNG" style="width: 90%;"><br>
                        <img src="../img/monacok_progress/CostAnalysis2.PNG" style="width: 90%;"><br><p style="font-size: 10px;"><b>Figure 4: </b><i>Cost-Analysis Component Tables</i></p>
                        <!--<img src="../img/monacok_progress/CostAnalysis3.PNG" style="width: 80%;"></td> -->
                    <td style="vertical-align: top; padding-top: 20px;">Once our team selected our primary components, I began a Cost-Analysis report to minimize cost
                        when selecting component suppliers. For each component, I created a table listing reliable
                        vendors with their respective cost multiplied by desired quantity of the in-stock component and
                        their shipping cost to Purdue University. Each table includes a quantity cell which, when
                        changed, will alter cost values automatically.<br><br>Finally, I calculated two totals: Cheapest
                        Individual Options and Mouser-Digikey Priority. As the name suggests, the Cheapest Individual
                        Options total was found by summing the least expensive supplier option from each component
                        table. If a supplier happened to supply the cheapest option for multiple components, the
                        shipping cost was only included once. The Mouser-Digikey Priority total uses Mouser and Digikey
                        suppliers when possible to reduce shipping cost. These two suppliers had multiple of the
                        desired components available and were the only reliable suppliers for certain components.<br><br>
                    <img src="../img/monacok_progress/CostAnalysis4.PNG" style="width: 100%;"><br><p style="text-align: center; font-size: 10px;"><b>Figure 5: </b><i>Cost-Analysis Totals</i></b></p><br>
                        The Mouser-Digikey Priority total was less expensive due to the savings earned from reduced
                        shipping costs. The images displayed show portions of the cost analysis document; however, as this is a
                        living document these numbers may not be up-to-date. The most recent version of this document
                        can be found on our <a href="https://engineering.purdue.edu/477grp6/Files/references.html">Reference Page</a>.
                    </td>
                </tr>
            </table><br>
            <table>
                <tr>
                    <td style="width: 70%;">Additionally, I reviewed various functionalities of the STM32 Microcontroller by practicing
                        blinking an on-board LED using timers and the on-board user pushbutton. I consulted the STM32F0xx
                        Reference Manual [1] to determine which timer could be linked to the on-board LED and to reference
                        multiple STM32F0 register structures such as GPIOx_MODER, RCC_AHBENR, and TIMx_CR1. Since it has
                        been a couple of years since I have programmed a microcontroller, I also referenced an Embedded
                        Systems textbook which includes programming syntax examples and concept theory for ARM Cortex-M
                        Microcontrollers [2]. The final result can be found on our <a href="https://engineering.purdue.edu/477grp6/Media/media.html">Media Page</a>.</td>
                    <td><p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/STM32F0.jpg" style="width: 150px;"><br><b>Figure 6: </b><i>STM32F0 Microcontroller Practice Set-up</i></p>
</td>
                </tr>
            </table>

            Our team is strongly considering using the STM System Workbench IDE for our
            project, so I used this IDE when programming the board. System Workbench can also interface with
            STMicroelectronics' relatively newer software STM32CubeMX which can generate initialization code for
            STM32 Microcontrollers via GUI. I installed STM32CubeMX to introduce myself to the application in
            case it proves useful. I intend to delve more into STM32CubeMX as well as other resources for STM32
            programming such as HAL Libraries, which seem to be increasingly popular for programming STM32
            controllers.<br><br>
            <p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/SystemWorkbench.PNG" style="width: 100%;" border="2px"><br><b>Figure 7: </b><i>STMicroelectronics System Workbench IDE</i></p>
            <br>
            <p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/STM32CubeMX.PNG" style="width: 100%;" border="2px"><br><b>Figure 8: </b><i>STMicroelectronics STM32CubeMX IDE</i></p>
            <br>
            <b>Next Week Plan:</b><br>
            <ul>
                <li>Ensure Order of Primary Components</li>
                <li>Practice Programming STM32L4 Microcontroller</li>
            </ul>
            <br>
            <b>Sources Cited:</b><br>
            <p style="line-height: 20px;">[1] ST.com. 2020. <i>STMicroelectronics.</i> [online] Available at: &lthttps://www.st.com/resource/en/reference_manual/dm00031936-stm32f0x1stm32f0x2stm32f0x8-advanced-armbased-32bit-mcus-stmicroelectronics.pdf> [Accessed 16 September 2020].<br>
                [2] Y. Zhu, <i>Embedded systems with ARM Cortex-M microcontrollers in assembly language and C Third Edition.</i> E-Man Press LLC, 2018.</p>

            <hr style="width: 70%; color: black; text-align: center; display: block; height: 1px; background-color: black; border: 0; margin-top: 40px; margin-bottom: 40px;">

            <h4>Week 5:</h4>
            <b>Date:</b> 24 September 2020<br>
            <b>Total hours:</b> 10<br>
            <b>Description of design efforts:</b><br><br>
            <table>
                <tr>
                    <td style="width: 30%;"><p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/STM32L476G-DISCO.jpg" style="height: 150px;"><br><b>Figure 9: </b><i>STM32L476G-DISCOVERY board</i></p></td>
                    <td>First, I created a list of components from our Bill of Materials to be ordered immediately. These are
            components our team is certain will be required for initial development, namely: LoRa Transceivers, GPS
            Receiver Development Boards, TOLED Displays, and IMU Development Boards. The microcontrollers will be
            ordered soon as well; however, each team member has their own chosen method for initial development. I will
            be continuing my development using the STM32L476G-DISCOVERY board.</td>
                </tr>
            </table>
            <br>
            I spent the majority of this week working with the STM32L4 to display information on the on-chip LCD screen
            and interface with an Adafruit MPU-6050 6-DoF IMU. My goal was to request and receive acceleration and gyro
            information from the MPU-6050 and display a portion of this data on the LCD display. During this process, I
            became more familiar with the STM32CubeMX IDE mentioned in last week's progress report. I used this
            application to create the initialization functions necessary for the System Clock, GPIO, and I2C
            functionality. <br><br>
            <table style="margin-left: auto; margin-right: auto; width: 80%;">
                <tr>
                    <td style="width: 40%"><p style="text-align: center; font-size: 10px; line-height: 15px;"><img src="../img/monacok_progress/STM32CubePinOutView.PNG" style="width: 250px;"><br><b>Figure 10: </b><i>STM32CubeMX Pin Out View of STM32L4 with Pin Initialization</i></p><br></td>
                    <td style="width: 60%;"><p style="text-align: center; font-size: 10px;"><img src="../img/monacok_progress/STM32CubeSystemView.PNG" style="width: 400px; margin-left: auto; margin-right: auto;"><br><b>Figure 11: </b><i>STM32CubeMX System View of Initialized Components</i></p><br></td>
                </tr>
            </table>
            The STM32CubeMX generated code also comes with all of the necessary Hardware Abstraction
            Layer (HAL) library files which can be used to code most any STM32 microcontroller at a higher level.
            Although the HAL Library was very useful for testing, my one concern is the memory size of the library and
            if the memory requirement can be satisfied in addition to the memory requirement of the graphic's libraries
            required for the Transparent OLED Display. There are many files included in the HAL library, a good number
            of which will be irrelevant to our project. While the net of dependancies seems complex, it may be possible
            to pick and choose the files we want to include from the HAL library, or we could use the HAL library as a
            reference for creating our own form of abstraction.<br><br>

            <table>
                <tr>
                    <td>The majority of the example code supplied for the MPU-6050 was Arduino based and used very high-level
            functions which did not give a good sense as to how the application was actually interfacing with the
            sensor. In order to work with the IMU, I referenced an online tutorial as well as the Embedded Systems
            textbook cited in last week's progress report [1] [2]. The code for interfacing with the LCD screen was
            created by referencing an example using the HAL library from the STM32CubeL4 expansion software. The end
            result is documented on our <a href="https://engineering.purdue.edu/477grp6/Media/media.html">Media Page</a>.<br><br>
                    <p style="text-align: center; font-size: 10px; line-height: 15px;"><img src="../img/monacok_progress/MPU6050.jpg" style="width: 250px;"><br><b>Figure 13: </b><i>Adafruit MPU-6050 6DoF IMU Sensor</i></p>
                    </td>
                    <td style="width: 40%"><p style="text-align: center; font-size: 10px; line-height: 15px;"><img src="../img/monacok_progress/STM32L4_SetUp.jpg" style="height: 350px;"><br><b>Figure 12: </b><i>STM32L4 LCD and IMU Practice Set-up</i></p></td>
                </tr>
            </table>

            <br><br>
            <b>Next Week Plan:</b><br>
            <ul>
                <li>Interface with Transparent OLED Display using the STM32L4 Microcontroller</li>
                <li>Complete the Software Formalization Assignment</li>
            </ul>
            <br>

            <b>Sources Cited:</b><br>
            <p style="line-height: 20px;">[1] ControllersTech.com. 2020. <i>ControllersTech.</i> [online] Available at: &lthttps://controllerstech.com/how-to-interface-mpu6050-gy-521-with-stm32/> [Accessed 22 September 2020].<br>
                [2] Y. Zhu, <i>Embedded systems with ARM Cortex-M microcontrollers in assembly language and C Third Edition.</i> E-Man Press LLC, 2018.</p>

            <hr style="width: 70%; color: black; text-align: center; display: block; height: 1px; background-color: black; border: 0; margin-top: 40px; margin-bottom: 40px;">

            <h4>Week 6:</h4>
            <b>Date:</b> 2 October 2020<br>
            <b>Total hours:</b> 8<br>
            <b>Description of design efforts:</b><br><br>
            The Sparkfun Transparent OLED Display arrived early last weekend, so I began investigating further into the
            graphics library provided by Sparkfun and the breakout board schematic. As with the MPU-6050, the resources
            associated with the Sparkfun TOLED Display use the Arduino environment, including the HyperDisplay library
            made specifically for Sparkfun display products. The HyperDisplay library, however, utilizes the SSD1309
            library which supports "display driver IC's without customization for any particular display hardware" [1].
            So although the HyperDisplay library is incompatible with System Workbench, I have begun experimenting with
            using the SSD1309 library in conjunction with the HAL library provided by STMicroelectronics to interface
            with the OLED display.<br><br>

            <table>
                <tr>
                    <td style="width: 65%;">As discussed previously, I will be using the SPI interface to communicate with the OLED display. This
            particular display can accommodate both I2C and SPI protocols with I2C as default. In order to use SPI with
            the display, 4 jumper connections must be severed on the breakout board. JP1 is connected to the
            No-Connection (I2C)/Slave Select (SPI) line on the board. The default configuration pulls the Slave Select
            low. For SPI, the Slave Select signal should only be pulled low when the slave is required by the master.
            Therefore, this jumper must be severed and the respective GPIO output pin pulled high. In I2C mode, JP2
            allows the user to change the I2C address from 0x30 (default) to 0x31, but severing this connection also
            releases the Data-Command pin for use in SPI mode. JP3 is the jumper that designates whether the display is
            in I2C mode (closed) or SPI mode (opened). Finally, JP4 determines if the SDA (I2C)/MOSI (SPI) pin should
            be bi-directional. For SPI, Master Out Slave In is a one directional signal, so the jumper should once
            again be severed. My display breakout board with severed jumper connections is shown on the right.
                    </td>
                    <td><p style="text-align: center; font-size: 10px; line-height: 15px;"><img src="../img/monacok_progress/OLED_Breakout_Jumpers.PNG" style="width: 250px;"><br><b>Figure 14: </b><i>TOLED Jumpers in SPI Configuration</i></p></td>
                </tr>
            </table>
            <br>
            I used STM32CubeMX to generate the initialization code for the GPIO, SPI, and System Clock registers,
            downloaded and integrated the SSD1309 library, and wrote a test "Hello World" program to display on the
            OLED. SPI is not compatible with the Qwiic connectors available on the board, so I used male headers to try
            and connect the development board to my test bread board. Unfortunately, the connection between the
            breakout board through holes and the header pins is too loose to provide a solid connection, so I cannot
            currently test for successful communication with the OLED display.
            <br><br>
            <p style="text-align: center; font-size: 10px; line-height: 15px;"><img src="../img/monacok_progress/OLED_Setup.jpg" style="width: 500px;"><br><b>Figure 15: </b><i>TOLED Test Set-up</i></p>

            <br><br>
            <b>Next Week Plan:</b><br>
            <ul>
                <li>Continue working with the Transparent OLED Display to establish communication</li>
                <li>Finalize the Software Formalization Assignment</li>
            </ul>
            <br>

            <b>Sources Cited:</b><br>
            <p style="line-height: 20px;">[1] GitHub.com. 2020. <i>GitHub, Inc.</i> [online] Available at: &lthttps://github.com/sparkfun/SparkFun_HyperDisplay> [Accessed 30 September 2020].<br>

            <hr style="width: 70%; color: black; text-align: center; display: block; height: 1px; background-color: black; border: 0; margin-top: 40px; margin-bottom: 40px;">

        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="../../js/jquery.js"></script>
<script src="../../js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("../../header.html");
	$("#menu").load("../../navbar.html");
	$("#footer").load("../../footer.html");
});
</script>
</body>
</html>
